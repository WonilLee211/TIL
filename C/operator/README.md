# operator

### 목차

1. [산술연산자, 대입연산자](#산술연산자-대입연산자)
2. [증감연산자](#증감연산자)
3. [비트연산자](#비트연산자)
4. [연산 우선순위](#복잡한-연산)


---


# 산술연산자, 대입연산자

```c

#include <stdio.h>

int main(void){
    int a, b;
    a = 10;
    b = 3;
    printf("a + b = %d\n", a + b);
    printf("a - b = %d\n", a - b);
    printf("a * b = %d\n", a * b);
    printf("a / b = %d\n", a / b);
    printf("a %% b = %d\n", a % b);
    return 0;
}
// a + b = 13
// a - b = 7
// a * b = 30
// a / b = 3
// a % b = 1
```
- '=' : 대입 연산자(Assignment Operator)

# 증감연산자

- `a++` : 후위형
    - 결과를 반환한 후 값을 증가시킴
- `++a`
    - 변수에 값을 증가시킨 후 결과를 반환

- 위 4 개의 연산 중에서 가장 빨리 연산되는 것은 a++ 과 같은 증감 연산
    - 왜냐하면, a = a + 1 의 경우 ADD a 1 로 하지만, a++ 은 INC a 로 좀 더 빨리 계산된다.
    - 최근 컴파일러는 최적화가 잘되어있어, a + 1 은 증감연산자로 처리해버린다.

# 비트연산자

`&` : and

`|` : or

`^` : xor

`<<` : 쉬프트연산자

`~` : 반전

## >> 연산

- 오른쪽으로 쉬프트 하되, 맨 오른쪽 숫자가 갈 자리가 없다면 그 숫자는 버려짐
- 맨 왼쪽은 맨 왼쪽에 있던 값이 채워짐

```c
#include <stdio.h>

int main() {
    int a = 0xAF; // 10101111
    int b = 0xB5; // 10110101

    printf("%x \n", a & b); // a % b = 10100101
    printf("%x \n", a | b); // a | b = 10111111
    printf("%x \n", a ^ b); // a ^ b = 00011010
    printf("%x \n", ~a);    // ~a = 1....1 01010000
    printf("%x \n", a << 2); // a << 2 = 1010111100
    printf("%x \n", a >> 3); // b >> 3 = 00010110
    
}

```

- `ìnt b` : `00000000 00000000 00000000 10110101`(4byte)
    - 실제 값이 위와 같은 형태로 저장되어 있기 때문에 `b >> 3`은 `00010110`이 된다.


# 복잡한 연산

![image](https://github.com/WonilLee211/TIL/assets/109330610/0adac7e1-60b7-4d53-a422-e2442b8b11d0)
