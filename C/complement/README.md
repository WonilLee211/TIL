# 2의 보수

- 덧셈을 고려했을 때 가장 자연스럽게 음수를 표현하는 방식

## 보수 계산법

- 2진수의 반전 + 1
- `~a + 1`

## 이진수의 부호 판별법

- 맨 앞 비트가 1이라면 음수, 0이라면 양수
- `1101` -> `~1101` -> `0010` -> `0011` -> -3

## 오버플로우

- 자료형의 최대값 범위를 벗어나는 값을 대입할 때 발생하는 에러

### 예시

- int 자료형의 최대 값인 2147483647에서 1을 더했을 경우

```c
int a = 2147483647 // 0x7FFFFFFF
a++; // 0x80000000
```

- 여기서 보수 표현법 체계하에서 해석한다면 

- `-(~a + 1)` = -0x80000000 = -2147483648
- 처럼 음수가 나와버리게 된다.

이러한 문제가 발생하지 않돌고 개발자 스스로 자료형 크기를 신경써야 한다.

## unsigned type

```c

#include <stdio.h>

int main() {
    unsigned int b = -1; // 0xFFFFFFFF
    printf("b에 들어있는 값을 unsigned int로 해석했을 때 값 : %u \n", b);
    // b 에 들어있는 값을 unsigned int 로 해석했을 때 값 : 4294967295 
    return 0;
}

```