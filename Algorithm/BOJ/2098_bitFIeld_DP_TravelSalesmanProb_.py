import sys
sys.stdin = open('input.txt')

'''
1 ~ n 번 도시
한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래 도시로 돌아오는 순회 여행 경로
한 번 갓던 도시로는 다시 못감
가장 적은 비용을 들이는 여행 계획 구하기

W[i][j] :각 도시 i에서 도시 j로 이동하는데 드는 비용 행렬(비대칭)
- 갈 수 없는 경우 W = 0

1초면 20만번 연산 허용

논리
- 모든 지점에서 출발해서 최소 비용
- 사이클을 만들어야 함.
- 조건 마지막 도시b는 첫 도시a와 연결되어있어야 함.
    - w[b][a] != 0

모든 순열을 구하는건 시간초과 : 1307674368000

비트필드를 이용한 다이나믹 프로그래밍

논리
- 각 노드에서 연결리스트 생성
- 모든 노드를 시작점으로 dp를 구해야 함
    - 
- 한 시작점에서 최소 사이클은 모든 지점에서의 최소 사이클이다

'''
import sys

input = sys.stdin.readline

n = int(input())
w = [list(map(int, input().split())) for _ in range(n)]
INF = 1000000 * n
dp = [[INF] * (1 << n) for i in range(n)] # 도시 번호 * 도시 연결 경우의 수(비트 필드)

# 0에서 갈 수 있는 곳 미리 표시
for i in range(1, n):
    if w[0][i] != 0:
        dp[i][1<<i] = w[0][i]

# 모든 비트 필드에 대해서 나아갈 수 있는 곳에 대해서 dp 계산
for i in range(1, 1 << n):
    for j in range(1, n):
        if dp[j][i] == INF: # 최소경로가 없다면 패스
            continue

        for k in range(1, n): # 현재의 위치에서 나아갈 수 있는 곳 찾아서
            if not(i & 1<<k) and w[j][k] != 0: # w :길이 있고,  아직 방문 안한 경우
                if dp[k][i ^ 1 << k] > dp[j][i] + w[j][k]: # 해당 위치의 dp보다 작다면 갱신
                    dp[k][i ^ 1 << k] = dp[j][i] + w[j][k]
'''
dp
[4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000]
[4000000, 4000000, 10, 4000000, 4000000, 4000000, 28, 4000000, 4000000, 4000000, 28, 4000000, 4000000, 4000000, 35, 4000000]
[4000000, 4000000, 4000000, 4000000, 15, 4000000, 19, 4000000, 4000000, 4000000, 4000000, 4000000, 29, 4000000, 29, 4000000]
[4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 20, 4000000, 20, 4000000, 27, 4000000, 31, 4000000]
'''
min_v = INF
for i in range(1, n): # 마지막 돌아오는 경로가 있고 그 중 가장 작은 값 저장
    if dp[i][(1 << n) - 2] != INF and w[i][0] != 0 and min_v > dp[i][(1 << n) - 2] + w[i][0]:
        min_v = dp[i][(1 << n) - 2] + w[i][0]

print(min_v)