# Entity Relations 

- JPA는 속성에 따라서 최적의 Query를 자동으로 생성하기 때문에 어떤 속성에 따라서 Query가 생성되는지 명확히 알아야 함
- **table과 entity를 열심히 설계해서 원하는 쿼리가 나오도록 하는 것이 jpa 고수로 가는 길**

## 2. 1:N relation

- User와 UserHistory를 바탕으로 학습
- 특정 user의 userHistory 목록을 조회하기


### `@OneToMany`

- 1:N 관계 설정 어노테이션
- 옵션
  1. fetch : 트랜잭션 처리 타입 설정(default: LAZY/ EAGER)


- nullPointException을 피하기 위해 기본값으로 빈배열 할당

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    private List<UserHistory> userHistories = new ArrayList<>();

}


```

- test code
  - jpa 기능없이 구현할 때 코드가 길어지고 가독성이 떨어짐
  - jpa를 활용하여 동일한 쿼리 구현 

```java
    @Test
    void userRelationTest(){

        UserTable user = new UserTable();
        user.setName("david");
        user.setEmail("david@fastcampus.com");
        user.setGender(Gender.MALE);
        userTableRepository.save(user);

        user.setName("daniel");
        userTableRepository.save(user);
        user.setEmail("daniel@fastcampus.com");
        userTableRepository.save(user);


//        userHistoryRepository.findAll().forEach(System.out::println);
        // 쿼리 메서드로 userId에 일치하는 userHistory 레코드 조회하기
//        List<UserHistory> result = userHistoryRepository.findByUserId(
//                userTableRepository
//                        .findByEmail("daniel@fastcampus.com")
//                        .getId()
//        );
//
//        result.forEach(System.out::println);

        // jpa @OneToMany relation으로 위의 쿼리 대체하기
        List<UserHistory> result = userTableRepository
                .findByEmail("daniel@fastcampus.com")
                .getUserHistories();

        result.forEach(System.out::println);


    }

```

- 정상적으로 조회되지 않음
  

```sql
    
    create table user_table_user_histories (
       user_table_id bigint not null,
        user_histories_id bigint not null
    )
```

- user_table_user_histories 이라는 mapping 테이블이 자동 생성됨
- 이 명칭을 설정해줄 필요가 있음

### `@JoinColumn`

- 옵션

  1. insertable : 생성 권한 설정
  2. updatable : 수정 권한 설정

- entity가 어떤 컬럼으로 조인을 하게 될지 설정하는 annotation
- default값은 해당필드명을 활용해서 만들어 줌
- 아래와 같이 설정 시, mapping 테이블이 사라지고 해당필드명으로 id필드를 피참조 db에 추가함

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn
    private List<UserHistory> userHistories = new ArrayList<>();

}

```
```sql
    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        user_histories_id bigint,
        primary key (id)
    )
    
    create table user_table (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        gender varchar(255),
        name varchar(255),
        primary key (id)
    )

```

- user_history  필드 중 user_id와 user_histories_id의 의미가 동일하기 때문에 일치시켜주기

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id")
    private List<UserHistory> userHistories = new ArrayList<>();

}

// --------------------------------

package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@NoArgsConstructor
@Data
public class UserHistory extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    private String name;

    private String email;

}

```
```sql

    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        primary key (id)
    )

-- -------------------------
...

Hibernate: 
    select
        userhistor0_.user_id as user_id6_3_0_,
        userhistor0_.id as id1_3_0_,
        userhistor0_.id as id1_3_1_,
        userhistor0_.created_at as created_2_3_1_,
        userhistor0_.updated_at as updated_3_3_1_,
        userhistor0_.email as email4_3_1_,
        userhistor0_.name as name5_3_1_,
        userhistor0_.user_id as user_id6_3_1_ 
    from
        user_history userhistor0_ 
    where
        userhistor0_.user_id=?


UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.613496, updatedAt=2022-12-26T00:58:27.613496), id=1, userId=6, name=david, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.697271, updatedAt=2022-12-26T00:58:27.697271), id=2, userId=6, name=daniel, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.703257, updatedAt=2022-12-26T00:58:27.703257), id=3, userId=6, name=daniel, email=daniel@fastcampus.com)

```

-  동일한 쿼리로 조회되는 것을 볼 수 있음

> 주의 : User entity에서 UserHistory의 read권한만 줘야 함

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private List<UserHistory> userHistories = new ArrayList<>();

}
```

## N:1 relation

- 일반적으로 `@ManyToOne`이 조금 더 깔끔하게 entity를 구성할 수 있음
- 양방향으로 참조 설정
  - 이전에 작성한 userId 필드 삭제
- UserHistory.getUser() : UserHistory에서 User 조회해보기
- 조회 관계가 어느 쪽이 빈번한지에 따라 적절한 관계로 맺어주는 것이 중요
  

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    @Id // pk
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NonNull
    private String name;
    @NonNull
    private String email;
    @Enumerated(value = EnumType.STRING)
    private Gender gender;

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    @ToString.Exclude
    private List<UserHistory> userHistories = new ArrayList<>();

}
// ----------------------------
package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@NoArgsConstructor
@Data
public class UserHistory extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;

    @ManyToOne
    private UserTable user;

}
// ------------------------------------------------------------
   @Test
    void userRelationTest(){

        UserTable user = new UserTable();
        user.setName("david");
        user.setEmail("david@fastcampus.com");
        user.setGender(Gender.MALE);
        userTableRepository.save(user);

        user.setName("daniel");
        userTableRepository.save(user);
        user.setEmail("daniel@fastcampus.com");
        userTableRepository.save(user);

        ...
        // 
        System.out.println("UserHistory.getUser() : " + userHistoryRepository.findAll().get(0).getUser());
    }

```

- 동일하게 user_history  table에 user_id필드로 저장됨을 볼 수 있음

```sql

    
    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        primary key (id)
    )
-- -------------------------------------------------
    select
        usertable0_.id as id1_4_0_,
        usertable0_.created_at as created_2_4_0_,
        usertable0_.updated_at as updated_3_4_0_,
        usertable0_.email as email4_4_0_,
        usertable0_.gender as gender5_4_0_,
        usertable0_.name as name6_4_0_,
        userhistor1_.user_id as user_id6_3_1_,
        userhistor1_.id as id1_3_1_,
        userhistor1_.id as id1_3_2_,
        userhistor1_.created_at as created_2_3_2_,
        userhistor1_.updated_at as updated_3_3_2_,
        userhistor1_.email as email4_3_2_,
        userhistor1_.name as name5_3_2_,
        userhistor1_.user_id as user_id6_3_2_ 
    from
        user_table usertable0_ 
    left outer join
        user_history userhistor1_ 
            on usertable0_.id=userhistor1_.user_id 
    where
        usertable0_.id=?

----------------------------------------------------
UserHistory.getUser() : UserTable(super=BaseEntity(createdAt=2022-12-26T01:27:31.765013, updatedAt=2022-12-26T01:27:31.951481), id=6, name=daniel, email=daniel@fastcampus.com, gender=MALE)

```

- 이전과 동일한 쿼리문으로 조회되는 것을 볼 수 있음
  
### erd에서 1:N relation 형성

```java
package com.jpa.fedeleo.bookmanager.domain;

@Entity
@Data
@NoArgsConstructor
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class Publisher extends BaseEntity{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany
    @JoinColumn(name = "publisher_id")
    private List<Book> books = new ArrayList<>();
}

package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@Data
@NoArgsConstructor
public class Book extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String category;

    private Long authorId;

    @OneToOne(mappedBy = "book")
    @ToString.Exclude
    private BookReviewInfo bookReviewInfo;

    @OneToMany
    @JoinColumn(name = "book_id")
    @ToString.Exclude // stackOverflow 피하기
    private List<Review> reviews = new ArrayList<>();

    @ManyToOne
    @ToString.Exclude
    private Publisher publisher;

}

package com.jpa.fedeleo.bookmanager.domain;

import lombok.*;

import javax.persistence.*;

@Entity
@Data
@NoArgsConstructor
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class Review extends BaseEntity{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String content;
    private float Score;

    @ManyToOne
    private UserTable user;

    @ManyToOne
    private Book book;

}

package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    @Id // pk
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NonNull
    private String name;
    @NonNull
    private String email;
    @Enumerated(value = EnumType.STRING)
    private Gender gender;

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    @ToString.Exclude
    private List<UserHistory> userHistories = new ArrayList<>();

    @OneToMany
    @JoinColumn(name = "user_id")
    @ToString.Exclude
    private List<Review> reviews = new ArrayList<>();

}

```

- 각 엔티티에 맞춰 repository 생성
- test code
### `@Transactional`

- private/protected 메서드는 @Transactional 무시
@Service
- Spring은 @Transactional이 적용된 모든 클래스/메서드에 대한 프록시 생성
- 프레임워크가 트랜잭션을 시작/커밋하기 위해 실행 중인 메서드의 전후로 트랜잭션 로직을 주입
- **옵션**
    - **isolation**
        - 트랜잭션에서 일관성없는 데이터 허용 수준을 설정 (격리 수준)
        - Dirty read: 동시 트랜잭션의 커밋되지 않은 변경 내용을 조회하는 상황 (데이터 불일치)
        - Nonrepeatable read: 동시 트랜잭션이 동일한 행을 업데이트하고 커밋하는 경우, 행을 다시 조회할 때 다른 값을 얻 는 상황
        - Phantom read: 다른 트랜잭션이 특정 범위의 행을 추가/제거할 경우, 커밋 전/후 조회 결과가 다른 상황
        - DEFAULT : DBMS의 기본 격리 수준 적용
        - READ_UNCOMMITED (level 0)
            - 트랜잭션의 동시 액세스 허용
            - 세 가지 동시성 부작용이 모두 발생 (Dirty read, Nonrepeatable read, Phantom read)
            - Postgres는 미지원(대신 READ_COMMITED 로 폴백), Oracle은 지원하거나 허용하지 않음
        - READ_COMMITED (level 1)
            - Dirty read 방지
            - 나머지 부작용은 여전히 발생할 수 있음 (Nonrepeatable read, Phantom read)
            - Postgres, SQL Server 및 Oracle의 기본 수준
        - REPEATEABLE_READ (level 2)
            - Dirty read, Nonrepeatable read 방지
            - 업데이트 손실을 방지하기 위해 필요한 가장 낮은 수준 (동시 액세스를 허용하지 않음)
            - Phantom read 부작용은 여전히 발생
            - MySQL의 기본 수준, Oracle은 미지원
        - SERIALIZABLE (level 3)
            - 가장 높은 격리 수준이지만, 동시 호출을 순차적으로 실행하므로 성능 저하의 우려
            - 모든 부작용을 방지

    - **propagation**
        - 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션 (전파 옵션)
        - REQUIRED (default)
            - 활성 트랜잭션이 있는지 확인하고, 아무것도 없으면 새 트랜잭션을 생성
        - SUPPORTS
            - 활성 트랜잭션이 있는지 확인하고, 있으면 기존 트랜잭션 사용. 없으면 트랜잭션 없이 실행
        - MANDATORY
            - 활성 트랜잭션이 있으면 사용하고, 없으면 예외 발생
        독립적으로 트랜잭션을 진행하면 안 되는 경우 사용
        - NEVER
            - 활성 트랜잭션이 있으면 예외 발생
        트랜잭션을 사용하지 않도록 제어할 경우
        - NOT_SUPPORTED
            - 현재 트랜잭션이 존재하면 트랜잭션을 일시 중단한 다음 트랜잭션 없이 비즈니스 로직 실행
        - REQUIRES_NEW
            - 현재 트랜잭션이 존재하는 경우, 현재 트랜잭션을 일시 중단하고 새 트랜잭션을 생성
        - NESTED
            - 트랜잭션이 존재하는지 확인하고 존재하는 경우 저장점을 표시
            - 비즈니스 로직 실행에서 예외가 발생하면 트랜잭션이 이 저장 지점으로 롤백
            - 활성 트랜잭션이 없으면 REQUIRED 처럼 작동
    - **noRollbackFor**
        - 특정 예외 발생 시 rollback이 동작하지 않도록 설정
    - **rollbackFor**
        - 특정 예외 발생 시 rollback이 동작하도록 설정
    - **timeout**
        - 지정한 시간 내에 해당 메소드 수행이 완료되이 않은 경우 rollback 수행 (단위: second)
        -1일 경우 no timeout (default : -1)
    - **readOnly**
        - 트랜잭션을 읽기 전용으로 설정
        - 성능을 최적화하기 위해 사용하거나, 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용
        - readOnly = true인 경우 INSERT, UPDATE, DELETE 작업 진행 시 실행 시 예외 발생(default : false

```java
package com.jpa.fedeleo.bookmanager.repository;

@SpringBootTest
public class BookRepositoryTest {

    @Autowired
    private BookRepository bookRepository;

    @Autowired
    private PublisherRepository publisherRepository;
    @Autowired
    private ReviewRepostory reviewRepostory;
    @Autowired
    private UserTableRepository userTableRepository;

    @Test
    @Transactional // @OneToMany 필드 전체의 fetch 설정에서 FETCHTYPE을 EAGER 설정하지 않아도 됨
    void bookRelationTest(){
        givenBookAndReview();

        UserTable user = userTableRepository.findByEmail("martin@fastcampus.com");
        System.out.println("Review : " + user.getReviews());
        System.out.println("Book : " + user.getReviews().get(0).getBook());
        System.out.println("Publisher : " + user.getReviews().get(0).getBook().getPublisher());

    }

    private void givenBookAndReview() {
        UserTable user = givenUser();
        Publisher publisher = givenPublisher();
        Book book = givenBook(publisher);
        givenReview(user, book);

    }

    ...
}

```

```sql
    select
        reviews0_.user_id as user_id8_4_0_,
        reviews0_.id as id1_4_0_,
        reviews0_.id as id1_4_1_,
        reviews0_.created_at as created_2_4_1_,
        reviews0_.updated_at as updated_3_4_1_,
        reviews0_.score as score4_4_1_,
        reviews0_.book_id as book_id7_4_1_,
        reviews0_.content as content5_4_1_,
        reviews0_.title as title6_4_1_,
        reviews0_.user_id as user_id8_4_1_,
        book1_.id as id1_1_2_,
        book1_.created_at as created_2_1_2_,
        book1_.updated_at as updated_3_1_2_,
        book1_.author_id as author_i4_1_2_,
        book1_.category as category5_1_2_,
        book1_.name as name6_1_2_,
        book1_.publisher_id as publishe7_1_2_,
        publisher2_.id as id1_3_3_,
        publisher2_.created_at as created_2_3_3_,
        publisher2_.updated_at as updated_3_3_3_,
        publisher2_.name as name4_3_3_,
        bookreview3_.id as id1_2_4_,
        bookreview3_.created_at as created_2_2_4_,
        bookreview3_.updated_at as updated_3_2_4_,
        bookreview3_.average_review_score as average_4_2_4_,
        bookreview3_.book_id as book_id6_2_4_,
        bookreview3_.review_count as review_c5_2_4_ 
    from
        review reviews0_ 
    left outer join
        book book1_ 
            on reviews0_.book_id=book1_.id 
    left outer join
        publisher publisher2_ 
            on book1_.publisher_id=publisher2_.id 
    left outer join
        book_review_info bookreview3_ 
            on book1_.id=bookreview3_.book_id 
    where
        reviews0_.user_id=?

Review : [Review(super=BaseEntity(createdAt=2022-12-26T10:12:17.154076400, updatedAt=2022-12-26T10:12:17.154076400), id=1, title=내 인생을 바꾼 책, content=꿀잼, Score=5.0, user=UserTable(super=BaseEntity(createdAt=2022-12-26T10:12:15.010932, updatedAt=2022-12-26T10:12:15.010932), id=1, name=martin, email=martin@fastcampus.com, gender=null), book=Book(super=BaseEntity(createdAt=2022-12-26T10:12:17.063314200, updatedAt=2022-12-26T10:12:17.063314200), id=1, name=jpa 바이블, category=null, authorId=null))]
Book : Book(super=BaseEntity(createdAt=2022-12-26T10:12:17.063314200, updatedAt=2022-12-26T10:12:17.063314200), id=1, name=jpa 바이블, category=null, authorId=null)
Publisher : Publisher(super=BaseEntity(createdAt=2022-12-26T10:12:16.784066300, updatedAt=2022-12-26T10:12:16.784066300), id=1, name=패스트 캠퍼스, books=[])

```