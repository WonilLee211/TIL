# Entity Relations 

- JPA는 속성에 따라서 최적의 Query를 자동으로 생성하기 때문에 어떤 속성에 따라서 Query가 생성되는지 명확히 알아야 함
- **table과 entity를 열심히 설계해서 원하는 쿼리가 나오도록 하는 것이 jpa 고수로 가는 길**


## 1. `@OneToOne`

### BookReviewInfo에서 Book정보 참조하기

```java

package com.jpa.fedeleo.bookmanager.domain;

@Data
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public class BaseEntity implements Auditable {
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

}
```

```java
package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@Data
@NoArgsConstructor
public class Book extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String category;

    private Long authorId;

    private Long publisherId;
}

```

- `@OneToOne` : db에 저장할 땐 참조 객체의 pk를 가져와서 저장함

```java
package com.jpa.fedeleo.bookmanager.domain;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class BookReviewInfo extends BaseEntity{
    @Id
    @GeneratedValue
    private Long id;

//    private Long bookId;

    @OneToOne
    private Book book;

    private float averageReviewScore;

    private int reviewCount;

}
```

- test : Book 객체를 생성 후 BookReviewInfo로 저장 

```java
    private Book givenBook(){
        Book book = new Book();
        book.setName("jpa 1:1 entity relations");
        book.setAuthorId(1L);
        book.setPublisherId(1L);

        return bookRepository.save(book);
    }

    private void bookReviewInfo(){
        BookReviewInfo bookReviewInfo = new BookReviewInfo();
        bookReviewInfo.setBook(givenBook());
        bookReviewInfo.setAverageReviewScore(4.5F);
        bookReviewInfo.setReviewCount(2);

        bookReviewInfoRepository.save(bookReviewInfo);

        System.out.println(">>>" + bookReviewInfoRepository.findAll());
    }

```

- DDL sql
  - book_review_info테이블에서 OneToOne relation으로 참조한 book 객체를 book_id로 저장됨

```sql
create table book (
    id bigint generated by default as identity,
    created_at timestamp,
    updated_at timestamp,
    author_id bigint,
    category varchar(255),
    name varchar(255),
    publisher_id bigint,
    primary key (id)
)

Hibernate: 

create table book_review_info (
    id bigint not null,
    created_at timestamp,
    updated_at timestamp,
    average_review_score float not null,
    review_count integer not null,
    book_id bigint,
    primary key (id)
)

```

- BookReviewInfo 조회할 때 book객체가 left Outer join
  
```sql
Hibernate: 
    insert 
    into
        book
        (id, created_at, updated_at, author_id, category, name, publisher_id) 
    values
        (default, ?, ?, ?, ?, ?, ?)
Hibernate: 
    call next value for hibernate_sequence
Hibernate: 
    insert 
    into
        book_review_info
        (created_at, updated_at, average_review_score, book_id, review_count, id) 
    values
        (?, ?, ?, ?, ?, ?)
Hibernate: 
    select
        bookreview0_.id as id1_2_,
        bookreview0_.created_at as created_2_2_,
        bookreview0_.updated_at as updated_3_2_,
        bookreview0_.average_review_score as average_4_2_,
        bookreview0_.book_id as book_id6_2_,
        bookreview0_.review_count as review_c5_2_ 
    from
        book_review_info bookreview0_
Hibernate: 
    select
        book0_.id as id1_1_0_,
        book0_.created_at as created_2_1_0_,
        book0_.updated_at as updated_3_1_0_,
        book0_.author_id as author_i4_1_0_,
        book0_.category as category5_1_0_,
        book0_.name as name6_1_0_,
        book0_.publisher_id as publishe7_1_0_ 
    from
        book book0_ 
    where
        book0_.id=?
>>>[BookReviewInfo(super=BaseEntity(createdAt=2022-12-24T22:41:35.230815, updatedAt=2022-12-24T22:41:35.230815), id=1, book=Book(super=BaseEntity(createdAt=2022-12-24T22:41:35.137066, updatedAt=2022-12-24T22:41:35.137066), id=1, name=jpa 1:1 entity relations, category=null, authorId=1, publisherId=1), averageReviewScore=4.5, reviewCount=2)]
Hibernate: 
    select
        bookreview0_.id as id1_2_0_,
        bookreview0_.created_at as created_2_2_0_,
        bookreview0_.updated_at as updated_3_2_0_,
        bookreview0_.average_review_score as average_4_2_0_,
        bookreview0_.book_id as book_id6_2_0_,
        bookreview0_.review_count as review_c5_2_0_,
        book1_.id as id1_1_1_,
        book1_.created_at as created_2_1_1_,
        book1_.updated_at as updated_3_1_1_,
        book1_.author_id as author_i4_1_1_,
        book1_.category as category5_1_1_,
        book1_.name as name6_1_1_,
        book1_.publisher_id as publishe7_1_1_ 
    from
        book_review_info bookreview0_ 
    left outer join
        book book1_ 
            on bookreview0_.book_id=book1_.id 
    where
        bookreview0_.id=?
>>>Book(super=BaseEntity(createdAt=2022-12-24T22:41:35.137066, updatedAt=2022-12-24T22:41:35.137066), id=1, name=jpa 1:1 entity relations, category=null, authorId=1, publisherId=1)

```

  
### OneToOne 제공 옵션 1. optional

- optional = false
  - 해당 참조 관계에 null이 허용되지 않음
  - not null constraint 추가

```java

package com.jpa.fedeleo.bookmanager.domain;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class BookReviewInfo extends BaseEntity{
    @Id
    @GeneratedValue
    private Long id;

//    private Long bookId;

    @OneToOne(optional = false)
    private Book book;

    private float averageReviewScore;

    private int reviewCount;

}

```

- join 조건이 inner join으로 변경됨
- 자바 객체의 조건에 따라 최적의 query문을 작성해주는 것이 jpa의 역할

```sql

...

Hibernate: 
    select
        book0_.id as id1_1_0_,
        book0_.created_at as created_2_1_0_,
        book0_.updated_at as updated_3_1_0_,
        book0_.author_id as author_i4_1_0_,
        book0_.category as category5_1_0_,
        book0_.name as name6_1_0_,
        book0_.publisher_id as publishe7_1_0_ 
    from
        book book0_ 
    where
        book0_.id=?
>>>[BookReviewInfo(super=BaseEntity(createdAt=2022-12-25T15:55:34.291777, updatedAt=2022-12-25T15:55:34.291777), id=1, book=Book(super=BaseEntity(createdAt=2022-12-25T15:55:34.176086, updatedAt=2022-12-25T15:55:34.176086), id=1, name=jpa 1:1 entity relations, category=null, authorId=1, publisherId=1), averageReviewScore=4.5, reviewCount=2)]

Hibernate: 
    select
        bookreview0_.id as id1_2_0_,
        bookreview0_.created_at as created_2_2_0_,
        bookreview0_.updated_at as updated_3_2_0_,
        bookreview0_.average_review_score as average_4_2_0_,
        bookreview0_.book_id as book_id6_2_0_,
        bookreview0_.review_count as review_c5_2_0_,
        book1_.id as id1_1_1_,
        book1_.created_at as created_2_1_1_,
        book1_.updated_at as updated_3_1_1_,
        book1_.author_id as author_i4_1_1_,
        book1_.category as category5_1_1_,
        book1_.name as name6_1_1_,
        book1_.publisher_id as publishe7_1_1_ 
    from
        book_review_info bookreview0_ 
    inner join
        book book1_ 
            on bookreview0_.book_id=book1_.id 
    where
        bookreview0_.id=?
>>>Book(super=BaseEntity(createdAt=2022-12-25T15:55:34.176086, updatedAt=2022-12-25T15:55:34.176086), id=1, name=jpa 1:1 entity relations, category=null, authorId=1, publisherId=1)

```

### Book에서 BookReviewInfo 정보 참조하기

- 참조 필드 추가

```java

package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@Data
@NoArgsConstructor
public class Book extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String category;

    private Long authorId;

    private Long publisherId;
    
    @OneToOne
    private BookReviewInfo bookReviewInfo; 
}

```

### OneToOne 제공 옵션 2. mappedBy

- 역참조할 때 사용
- 선언한 위치의 필드는 db에서 사라짐
- 따라서, 기본 참조 필드를 가지는 객체가 아닌 역참조하는 relation 내에 필드를 추가하고 mappedBy옵션을 설정하기
    - entity를 참조하는 경우 toString()같은 메서드가 순환 오버플로우 발생함
    - 그래서 단방향으로 걸거나, toString에서 제외시켜야 함

```java
package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@Data
@NoArgsConstructor
public class Book extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String category;

    private Long authorId;

    private Long publisherId;

    @OneToOne(mappedBy = "book")
    @ToString.Exclude
    private BookReviewInfo bookReviewInfo;
}


```

- book relation에서는 bookReviewInfo_id가 사라짐
- book_review_info relation에서는 book_id가 유지됨

```sql
Hibernate: 
    
    create table book (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        author_id bigint,
        category varchar(255),
        name varchar(255),
        publisher_id bigint,
        primary key (id)
    )
Hibernate: 
    
    create table book_review_info (
       id bigint not null,
        created_at timestamp,
        updated_at timestamp,
        average_review_score float not null,
        review_count integer not null,
        book_id bigint not null,
        primary key (id)
    )
```

- bookRepository에서 BookReViewInfo조회하기
```java
  @Test
    void crudTest2(){

        ...

        BookReviewInfo result1 = bookRepository
                .findById(1L)
                .orElseThrow(RuntimeException::new)
                .getBookReviewInfo();

        System.out.println(">>>" + result1);

    }

```
```sql
...

Hibernate:  
    select
        book0_.id as id1_1_0_,
        book0_.created_at as created_2_1_0_,
        book0_.updated_at as updated_3_1_0_,
        book0_.author_id as author_i4_1_0_,
        book0_.category as category5_1_0_,
        book0_.name as name6_1_0_,
        book0_.publisher_id as publishe7_1_0_,
        bookreview1_.id as id1_2_1_,
        bookreview1_.created_at as created_2_2_1_,
        bookreview1_.updated_at as updated_3_2_1_,
        bookreview1_.average_review_score as average_4_2_1_,
        bookreview1_.book_id as book_id6_2_1_,
        bookreview1_.review_count as review_c5_2_1_ 
    from
        book book0_ 
    left outer join
        book_review_info bookreview1_ 
            on book0_.id=bookreview1_.book_id 
    where
        book0_.id=?

>>>BookReviewInfo(super=BaseEntity(createdAt=2022-12-25T16:54:32.569599, updatedAt=2022-12-25T16:54:32.569599), id=1, book=Book(super=BaseEntity(createdAt=2022-12-25T16:54:32.483829, updatedAt=2022-12-25T16:54:32.483829), id=1, name=jpa 1:1 entity relations, category=null, authorId=1, publisherId=1), averageReviewScore=4.5, reviewCount=2)


```

## 2. 1:N relation

- User와 UserHistory를 바탕으로 학습
- 특정 user의 userHistory 목록을 조회하기


### `@OneToMany`

- 1:N 관계 설정 어노테이션
- 옵션
  1. fetch : 트랜잭션 처리 타입 설정(default: LAZY/ EAGER)


- nullPointException을 피하기 위해 기본값으로 빈배열 할당

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    private List<UserHistory> userHistories = new ArrayList<>();

}


```

- test code
  - jpa 기능없이 구현할 때 코드가 길어지고 가독성이 떨어짐
  - jpa를 활용하여 동일한 쿼리 구현 

```java
    @Test
    void userRelationTest(){

        UserTable user = new UserTable();
        user.setName("david");
        user.setEmail("david@fastcampus.com");
        user.setGender(Gender.MALE);
        userTableRepository.save(user);

        user.setName("daniel");
        userTableRepository.save(user);
        user.setEmail("daniel@fastcampus.com");
        userTableRepository.save(user);


//        userHistoryRepository.findAll().forEach(System.out::println);
        // 쿼리 메서드로 userId에 일치하는 userHistory 레코드 조회하기
//        List<UserHistory> result = userHistoryRepository.findByUserId(
//                userTableRepository
//                        .findByEmail("daniel@fastcampus.com")
//                        .getId()
//        );
//
//        result.forEach(System.out::println);

        // jpa @OneToMany relation으로 위의 쿼리 대체하기
        List<UserHistory> result = userTableRepository
                .findByEmail("daniel@fastcampus.com")
                .getUserHistories();

        result.forEach(System.out::println);


    }

```

- 정상적으로 조회되지 않음
  

```sql
    
    create table user_table_user_histories (
       user_table_id bigint not null,
        user_histories_id bigint not null
    )
```

- user_table_user_histories 이라는 mapping 테이블이 자동 생성됨
- 이 명칭을 설정해줄 필요가 있음

### `@JoinColumn`

- 옵션

  1. insertable : 생성 권한 설정
  2. updatable : 수정 권한 설정

- entity가 어떤 컬럼으로 조인을 하게 될지 설정하는 annotation
- default값은 해당필드명을 활용해서 만들어 줌
- 아래와 같이 설정 시, mapping 테이블이 사라지고 해당필드명으로 id필드를 피참조 db에 추가함

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn
    private List<UserHistory> userHistories = new ArrayList<>();

}

```
```sql
    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        user_histories_id bigint,
        primary key (id)
    )
    
    create table user_table (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        gender varchar(255),
        name varchar(255),
        primary key (id)
    )

```

- user_history  필드 중 user_id와 user_histories_id의 의미가 동일하기 때문에 일치시켜주기

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id")
    private List<UserHistory> userHistories = new ArrayList<>();

}

// --------------------------------

package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@NoArgsConstructor
@Data
public class UserHistory extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    private String name;

    private String email;

}

```
```sql

    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        primary key (id)
    )

-- -------------------------
...

Hibernate: 
    select
        userhistor0_.user_id as user_id6_3_0_,
        userhistor0_.id as id1_3_0_,
        userhistor0_.id as id1_3_1_,
        userhistor0_.created_at as created_2_3_1_,
        userhistor0_.updated_at as updated_3_3_1_,
        userhistor0_.email as email4_3_1_,
        userhistor0_.name as name5_3_1_,
        userhistor0_.user_id as user_id6_3_1_ 
    from
        user_history userhistor0_ 
    where
        userhistor0_.user_id=?


UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.613496, updatedAt=2022-12-26T00:58:27.613496), id=1, userId=6, name=david, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.697271, updatedAt=2022-12-26T00:58:27.697271), id=2, userId=6, name=daniel, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-12-26T00:58:27.703257, updatedAt=2022-12-26T00:58:27.703257), id=3, userId=6, name=daniel, email=daniel@fastcampus.com)

```

-  동일한 쿼리로 조회되는 것을 볼 수 있음

> 주의 : User entity에서 UserHistory의 read권한만 줘야 함

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    ...

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private List<UserHistory> userHistories = new ArrayList<>();

}
```

## N:1 relation

- 일반적으로 `@ManyToOne`이 조금 더 깔끔하게 entity를 구성할 수 있음
- 양방향으로 참조 설정
  - 이전에 작성한 userId 필드 삭제
- UserHistory.getUser() : UserHistory에서 User 조회해보기
- 조회 관계가 어느 쪽이 빈번한지에 따라 적절한 관계로 맺어주는 것이 중요
  

```java
package com.jpa.fedeleo.bookmanager.domain;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
public class UserTable extends BaseEntity{

    @Id // pk
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NonNull
    private String name;
    @NonNull
    private String email;
    @Enumerated(value = EnumType.STRING)
    private Gender gender;

    //nullPointException을 피하기 위해 기본 리스트 생성
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    @ToString.Exclude
    private List<UserHistory> userHistories = new ArrayList<>();

}
// ----------------------------
package com.jpa.fedeleo.bookmanager.domain;

@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Entity
@NoArgsConstructor
@Data
public class UserHistory extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;

    @ManyToOne
    private UserTable user;

}
// ------------------------------------------------------------
   @Test
    void userRelationTest(){

        UserTable user = new UserTable();
        user.setName("david");
        user.setEmail("david@fastcampus.com");
        user.setGender(Gender.MALE);
        userTableRepository.save(user);

        user.setName("daniel");
        userTableRepository.save(user);
        user.setEmail("daniel@fastcampus.com");
        userTableRepository.save(user);

        ...
        // 
        System.out.println("UserHistory.getUser() : " + userHistoryRepository.findAll().get(0).getUser());
    }

```

- 동일하게 user_history  table에 user_id필드로 저장됨을 볼 수 있음

```sql

    
    create table user_history (
       id bigint generated by default as identity,
        created_at timestamp,
        updated_at timestamp,
        email varchar(255),
        name varchar(255),
        user_id bigint,
        primary key (id)
    )
-- -------------------------------------------------
    select
        usertable0_.id as id1_4_0_,
        usertable0_.created_at as created_2_4_0_,
        usertable0_.updated_at as updated_3_4_0_,
        usertable0_.email as email4_4_0_,
        usertable0_.gender as gender5_4_0_,
        usertable0_.name as name6_4_0_,
        userhistor1_.user_id as user_id6_3_1_,
        userhistor1_.id as id1_3_1_,
        userhistor1_.id as id1_3_2_,
        userhistor1_.created_at as created_2_3_2_,
        userhistor1_.updated_at as updated_3_3_2_,
        userhistor1_.email as email4_3_2_,
        userhistor1_.name as name5_3_2_,
        userhistor1_.user_id as user_id6_3_2_ 
    from
        user_table usertable0_ 
    left outer join
        user_history userhistor1_ 
            on usertable0_.id=userhistor1_.user_id 
    where
        usertable0_.id=?

----------------------------------------------------
UserHistory.getUser() : UserTable(super=BaseEntity(createdAt=2022-12-26T01:27:31.765013, updatedAt=2022-12-26T01:27:31.951481), id=6, name=daniel, email=daniel@fastcampus.com, gender=MALE)

```

- 이전과 동일한 쿼리문으로 조회되는 것을 볼 수 있음
  


